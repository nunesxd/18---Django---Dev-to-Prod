-- python manage.py runserver 
>>> Roda o nosso servidor, se este nunca foi inicializado, cria a pasta principal do projeto (ou app), com os respectivos arquivos base.

-- python manage.py startapp pages
>>> Cria um novo app em nosso site, lembrando que é necessário incluí-lo no array 'INSTALLED_APPS', dentro do script 'settings', no projeto principal (sintaxe: 'XXXX.apps.XXXXConfig' - XXXX sendo o nome do novo app).

>>> Criamos um 'urls.py' dentro do app 'pages', este arquivo irá conter as rotas. Este arquivo não é criado por padrão pelo django.
Dentro de 'urls.py', associamos as views criadas junto as suas respectivas rotas.
Por fim, adicionamos a nova rota dentro do 'urls.py' do app principal 'btre', de forma que a url principal, o root de nosso site, seja sempre do app 'pages'.
. OBS: Poderíamos colocar como 'pages/', mas usando apenas o '', nós deixamos a pagina index como sendo a principal de nosso site;

>>> Adicionamos em 'settings.py', no array JSON 'TEMPLATES', item 'DIRS', o local de nossa pasta de templates.
Criamos os templates específicos para a landing page 'pages', e atualizamos o 'urls' para acessa-los.
Criamos o template 'base.html' para extender nos demais templates que serão usados no site, usando o jinja ({%  %}) para possibilitar a passagem de variáveis e demais conteúdos.

>>> Adicionamos os arquivos estáticos (css, js, img's, etc.) ao projeto dentro da pasta principal 'btre'.
Adicionamos ao 'settings.py', as demais variáveis relacionadas: 'STATIC_ROOT', 'STATICFILES_DIRS'.
-- python manage.py collectstatic
Por fim, rodamos o comando acima para consolidar na pasta do 'STATIC_ROOT', os arquivos separados nos diretórios 'STATICFILES_DIRS', dentre outros, como os do 'admin', que é criado por padrão pelo django.
Não é recomendado realizarmos o upload destes arquivos no GIT, por isso esta pasta é adicionada ao '.gitignore'

>>> Desenvolvemos os templates criados anteriormente, integrando o bootstrap e demais bibliotecas usadas. Lembrando que devemos mudar o diretório dos arquivos estáticos, transformando-os em variáveis, para isso devemos usar o Jinja, comandos usados: '{% load static %}' (no inicio do arquivo), '{% block content %}' '{% endblock %}', '{% static 'css/all.css'%}' (para cada arquivo estático utilizado).

>>> Utilizamos o 'partials' para segregar o html base ainda mais, entre 'top bar', 'nav bar' e 'footer'. Por boas práticas, devemos nomear os htmls do partials com um '_' na frente.

>>> Copiamos o conteúdo HTML para os respectivos templates, lembrando da necessidade de mudar alguns referênciais posteriormente, refletindo a necessidade de dinamicidade do código.
. OBS: O 'extends' dos partials, sempre deve ser a primeira linha do código, mesmo com o 'load static'.
Outra alteração que fazemos é o 'linking' entre as partes do site, para isso usamos: {% url 'XXXX' %} (XXXX sendo o respectivo html, mas sem a extensão 'html' no final). Este código usa a variável 'name' que demos ao app 'pages', nas rotas 'index', 'about', etc.
Uma outra funcionalidade adicionada é a adição do 'active' no HTML do '_navbar' de forma dinâmica. Para isso devemos usar os condicionais do Jinja, exemplo: 
{% if '/' == request.path %} ou {% if 'about' in request.path %}
    class="active"
{% else %}
    class=""
{% endif %}

>>> Criamos os demais apps da página: 'listings' e 'realtors', criando também um arquivo de urls para eles, adicionando-os aos apps no 'settings'. A ideia aqui é terminar o desenvolvimento do front-end, para seguirmos com o back-end.
Quanto as rotas do app 'listings', além do template de todos os listings, também queremos o acesso a um listing específico, para isso, o usuário deverá passar o respectivo id pela URL, isso pode ser feito pelo comando: '<int:listing_id>' (onde 'int' é o tipo do dado que estamos recebendo, um tipo de parser).