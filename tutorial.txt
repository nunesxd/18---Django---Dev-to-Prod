>>> Inicialmente criamos o nosso projeto localmente e utilizamos o 'venv' (Virtual Enviroment) para estabelecer o ambiente virtual, o venv é uma biblioteca integrada ao Python. Comando para instalar:
-- python -m venv ./venv (O './venv' é o local ao qual queremos criar nosso ambiente virtual)

-- python manage.py runserver 
>>> Roda o nosso servidor, se este nunca foi inicializado, cria a pasta principal do projeto (ou app), com os respectivos arquivos base.

-- python manage.py startapp pages
>>> Cria um novo app em nosso site, lembrando que é necessário incluí-lo no array 'INSTALLED_APPS', dentro do script 'settings', no projeto principal (sintaxe: 'XXXX.apps.XXXXConfig' - XXXX sendo o nome do novo app).

>>> Criamos um 'urls.py' dentro do app 'pages', este arquivo irá conter as rotas. Este arquivo não é criado por padrão pelo django.
Dentro de 'urls.py', associamos as views criadas junto as suas respectivas rotas.
Por fim, adicionamos a nova rota dentro do 'urls.py' do app principal 'btre', de forma que a url principal, o root de nosso site, seja sempre do app 'pages'.
. OBS: Poderíamos colocar como 'pages/', mas usando apenas o '', nós deixamos a pagina index como sendo a principal de nosso site;

>>> Adicionamos em 'settings.py', no array JSON 'TEMPLATES', item 'DIRS', o local de nossa pasta de templates.
Criamos os templates específicos para a landing page 'pages', e atualizamos o 'urls' para acessa-los.
Criamos o template 'base.html' para extender nos demais templates que serão usados no site, usando o jinja ({%  %}) para possibilitar a passagem de variáveis e demais conteúdos.

>>> Adicionamos os arquivos estáticos (css, js, img's, etc.) ao projeto dentro da pasta principal 'btre'.
Adicionamos ao 'settings.py', as demais variáveis relacionadas: 'STATIC_ROOT', 'STATICFILES_DIRS'.
-- python manage.py collectstatic
Por fim, rodamos o comando acima para consolidar na pasta do 'STATIC_ROOT', os arquivos separados nos diretórios 'STATICFILES_DIRS', dentre outros, como os do 'admin', que é criado por padrão pelo django.
Não é recomendado realizarmos o upload destes arquivos no GIT, por isso esta pasta é adicionada ao '.gitignore'. Usamos o site 'https://www.gitignore.io/' para criarmos um gitignore completo para o django, com todas as pastas e arquivos que geralmente são desconsiderados.

>>> Desenvolvemos os templates criados anteriormente, integrando o bootstrap e demais bibliotecas usadas. Lembrando que devemos mudar o diretório dos arquivos estáticos, transformando-os em variáveis, para isso devemos usar o Jinja, comandos usados: '{% load static %}' (no inicio do arquivo), '{% block content %}' '{% endblock %}', '{% static 'css/all.css'%}' (para cada arquivo estático utilizado).

>>> Utilizamos o 'partials' para segregar o html base ainda mais, entre 'top bar', 'nav bar' e 'footer'. Por boas práticas, devemos nomear os htmls do partials com um '_' na frente.

>>> Copiamos o conteúdo HTML para os respectivos templates, lembrando da necessidade de mudar alguns referênciais posteriormente, refletindo a necessidade de dinamicidade do código.
. OBS: O 'extends' dos partials, sempre deve ser a primeira linha do código, mesmo com o 'load static'.
Outra alteração que fazemos é o 'linking' entre as partes do site, para isso usamos: {% url 'XXXX' %} (XXXX sendo o respectivo html, mas sem a extensão 'html' no final). Este código usa a variável 'name' que demos ao app 'pages', nas rotas 'index', 'about', etc.
Uma outra funcionalidade adicionada é a adição do 'active' no HTML do '_navbar' de forma dinâmica. Para isso devemos usar os condicionais do Jinja, exemplo: 
-- {% if '/' == request.path %} ou {% if 'about' in request.path %}
    class="active"
{% else %}
    class=""
{% endif %}

>>> Criamos os demais apps da página: 'listings' e 'realtors', criando também um arquivo de urls para eles, adicionando-os aos apps no 'settings'. A ideia aqui é terminar o desenvolvimento do front-end, para seguirmos com o back-end.
Quanto as rotas do app 'listings', além do template de todos os listings, também queremos o acesso a um listing específico, para isso, o usuário deverá passar o respectivo id pela URL, isso pode ser feito pelo comando: '<int:listing_id>' (onde 'int' é o tipo do dado que estamos recebendo, um tipo de parser).

>>> Criamos a nossa base de dados chamada 'btre', o curso se utiliza do Postgres, mas iremos utilizar o SQL Server.
Para conexão com o django, baixamos o pacote 'mssql-django' e configuramos o django adequadamente, com atenção a configuração da porta, que retorna um erro caso não seja feita corretamente.

>>> Com a base criada, criamos o modelo, que é uma classe de nome singular e com a primeira letra maiúscula.
Vamos aos comandos comuns:
- 'on_delete=models.DO_NOTHING': Refere ao que se fazer quanto a deleção do item na tabela secundária, se a primaria deve ou não manter as informações, nesse caso ela deve manter;
- 'models.CharField(max_length=200)': Campo de texto comum, onde podemos setar algumas configurações, como o tamanho máximo do campo;
- 'models.TextField(blank=True)': Também um campo de texto, mas permite um tamanho maior, o blank faz com que o campo seja opcional;
- 'models.IntegerField()': Campo inteiro, não é necessário passar nenhum outro parâmetro;
- 'models.DecimalField(max_digits=2, decimal_places=1)': Campo de número float, onde podemos definir a quantidade de números e o número de decimais, por parâmetro;
- 'models.ImageField(upload_to='photos/%Y/%m/%d/')': Campo especial para fotos no Django. Dentro da base de dados este campo será um string, mas o Django considera o campo de uma forma diferente. Passamos por parâmetro a pasta que queremos que o Django salve temporariamente os arquivos (o django criará uma pasta chamada 'midia' e uma outra com o nome que especificarmos, diferenciando por datas).
Além da definição dos campos no modelo, definimos também o campo principal que será apresentado nas tabelas, através do comando abaixo:
-- def __str__(self):
    return self.title

. OBS: É possível acessarmos qualquer outro app diretamente pelo código, usando o 'from [app].[modulo] import [item]' mesmo.

-- python manage.py makemigration
>>> Este comando cria um arquivo que possibilita a criação das tabelas na base de dados, mas as bases não são criadas imediatamente.

-- python manage.py sqlmigrate listings 0001
>>> Nos é apresetando o comando SQL capaz da criação da respectiva tabela na base de dados. 'listings' é o nome do app, que será o nome da tabela, '0001' é o nome do arquivo criado pelo comando 'makemigrations', que contém os detalhes de todos os campos a serem criados, embora não estejam em SQL ainda.
Por fim, rodamos o 'migrate', que gera de fato a tabela com os respectivos campos.

>>> O Django já possui um local específico para os admins, basta abrir o servidor e acessar o seu link + '/admin'. O problema é que não temos um usuários admin logo no começo, devemos criá-lo com comando abaixo:
-- python manage.py createsuperuser
A princípo, os usuários admin só tem acesso para adicionar usuários e grupos ao site. Dentro do módulo principal do projeto 'btre', temos um módulo de 'admin'. Nele podemos adicionr os respectivos modelos para serem manipulados pelos super usuários, ex:
-- admin.site.register(Listing)
Onde 'Listing' é o modelo que criamos, lembrando que devemos importar os modelos para serem 'registrados' no módulo admin.

>>> Adicionamos algumas configurações para a pasta de 'media' (parecido com o que foi feito para os arquivos estáticos - variáveis 'MEDIA_ROOT' e 'MEDIA_URL'), que irá conter as fotos que configuramos em nosso banco de dados.
Para usarmos a pasta, adicionamos-a ao módulo 'urls.py' do projeto principal 'btre', ex:
-- urlpatterns = [] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
Ao adicionarmos os realtors e os listings, é possível identificar que as imagens foram adicionadas a pasta 'media' dentro do projeto, separando pela data da inserção da imagem.

>>> Em seguida, queremos customizar o site do 'admin', como o site já existe internamente no Django, podemos tirar proveito disso e apenas alterar aquilo que queremos, exemplo:
O template deve ser chamado como 'base_site.html', dentro da pasta 'admin'. 
Dentro do html / jinja, devemos extender 'admin/base.html' e podemos alterar o bloco 'branding', desta forma podemos alterar a parte que fica como 'Django Administration'.
Também podemos acrescentar um novo arquivo stylesheet, usando o bloco 'extrastyle'. Podemos usar o dev console para identificar os respectivos ids e classes que podemos substituir.